# Написать интерпретатор и интерактивный редактор для следующего языка:

## Грамматика:

```
expr ::= expr op expr | (expr) | identifier | { expr, expr } | number |
map(expr, identifier -> expr) | reduce(expr, expr, identifier identifier -> expr)
op ::= + | - | * | / | ^
stmt ::= var identifier = expr | out expr | print “string”
program ::= stmt | program stmt
```

## Пояснения:
1. number - произвольное целое или вещественное число 
1. приоритеты операторов такие (в возрастающем порядке): + и -, * и /, ^
1. {expr1, expr2}, где expr1 и expr2 - выражения с целым результатом - последовательность чисел  { expr1, expr1 + 1, expr + 2 .. expr2 } включительно. Если результат вычисления expr1 или expr2 не целый или expr1 > expr2, результат не определен.
1. map - оператор над элементами последовательности, применяет отображение к элементам последовательности и получает другую последовательность. Последовательность может из целой стать вещественной. Лямбда у map имеет один параметр - элемент последовательности.
1. reduce - свертка последовательности. Первый аргумент - последовательность, второй - нейтральный элемент, третий - операция. Свертка применяет операцию (лямбду) ко всем элементам последовательности. Например, “reduce({5, 7}, 1, x y -> x * y)” должен вычислять 1 * 5 * 6 * 7. Можно полагаться на то, что операция в reduce будет ассоциативна.
1. области видимости переменных - от ее объявления (var) до конца файла. Переменные у лямбд в map / reduce - имеют областью видимости соответствующую лямбду. У лямбд отсутствует замыкание, к глобальным переменным обращаться нельзя
1. out, print - операторы вывода. “string” - произвольная строковая константа, не содержащая кавычек, без экранирования

## Пример:
```
var n = 5
var sequence = map({1, n}, i -> (-1)^i / (2 * i + 1))
var pi = 4 * reduce(sequence, 0, x y -> x + y)
print “pi = “
out pi
```

## Требования к интерпретатору:
1. Интерпретатор должен выдавать ошибки парсинга и ошибки несоответствия типов (складывание чисел и последовательностей, применение map/reduce к числам, итд).
2. map и reduce должны выполняться интерпретатором параллельно по разумной стратегии. 
3. Все, что не учтено в правилах грамматики, на Ваше усмотрение.

## Требования к редактору:
1. Ошибки от интерпретатора должны подсвечиваться "на лету”.
1. Результат работы программы должен рассчитываться в фоне и автоматически показываться.
1. Долгие вычисления не должны приводить к блокировке UI.
1. UI на Ваше усмотрение.

## Требования к реализации и оформлению:
1. Программа должна быть написана на Java. 
1. Можно разумно использовать сторонние библиотеки.
1. Исходный код должен быть предоставлен в виде полностью настроенного самодостаточного проекта, размещенного на github.
1. Должен быть предоставлен необходимый набор тестов.

Цель задания - самостоятельно заработать небольшой продукт от начала до конца.  
Будут оцениваться UI, функциональность, архитектура, качество кода, тестовое покрытие, а также эффективность реализации.  

Перед началом работы желательно накидать и прислать приблизительный план: список предполагаемых подсистем, библиотек, и оценка по времени на реализацию подсистем. План не подразумевает жесткого следования, но является хорошей отправной точкой.
